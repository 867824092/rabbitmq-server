#@ load("@ytt:data", "data")
#@ load("util.star", "to_build_args")
#@ load("helpers.star", "ci_image", "ci_image_tag", "skip_ci_condition")

#@ def prepare_jobs(erlang_version=None, build_erlang=False):
prepare:
  name: prepare
  runs-on: ubuntu-18.04
  if: #@ skip_ci_condition()
  outputs:
    branch_or_tag_name: ${{ steps.ref.outputs.branch_or_tag_name }}
  #@yaml/text-templated-strings
  steps:
    - name: CHECKOUT REPOSITORY
      uses: actions/checkout@v2
    - name: CONFIGURE OTP & ELIXIR
      uses: actions/setup-elixir@v1
      with:
        otp-version: #@ erlang_version
        elixir-version: #@ data.values.elixir_version
    - name: CHECK RABBITMQ COMPONENTS
      id: ref
      run: |
        branch_or_tag_name=${GITHUB_REF#refs/*/}
        echo "::set-output name=branch_or_tag_name::$branch_or_tag_name"
    #@ if build_erlang:
    - name: CHECKOUT ERLANG/OTP MASTER
      uses: actions/checkout@v2
      with:
        repository: erlang/otp
        path: erlang-git-master
    - name: DETERMINE ERLANG SHA
      id: erlang_sha
      run: |
        cd erlang-git-master
        erlang_sha=$(git rev-parse HEAD)
        echo "::set-output name=erlang_sha::$erlang_sha"
    - name: CLEANUP ERLANG/OTP MASTER
      run: |
        rm -rf erlang-git-master
    #@ end
    #@ if erlang_version != "git":
    - name: CACHE SECONDARY UMBRELLAS
      uses: actions/cache@v2
      with:
        path: umbrellas
        key: #@ "secondary-umbrellas-{}-erlang-{}".format("-".join(data.values.secondary_umbrella_gitrefs), erlang_version)
    - name: PREPARE SECONDARY UMBRELLA COPIES
      #@ versions = " ".join(data.values.secondary_umbrella_gitrefs)
      run: |
        set -ex
        for version in (@= versions @); do
          umbrella="umbrellas/$version"
          if ! test -d "$umbrella"  ||
              ! make -C "$umbrella/deps/rabbit" test-dist; then
            rm -rf "$umbrella"
            git config --global advice.detachedHead false
            git clone \
              https://github.com/rabbitmq/rabbitmq-public-umbrella.git \
              "$umbrella"
            # `make co` in the public umbrella will use files from rabbitmq-server
            # to know what to fetch, and these are now different post monorepo. So,
            # we must clone rabbitmq-server manually and check out $version before
            # we run `make co`
            mkdir -p "$umbrella"/deps
            git clone \
              https://github.com/rabbitmq/rabbitmq-server.git \
              "$umbrella"/deps/rabbit
            git -C "$umbrella"/deps/rabbit checkout "$version"
            make -C "$umbrella" co
            make -C "$umbrella" up BRANCH="$version"
            # To remove third-party deps which were checked out when the
            # projects were on the `master` branch. Thus, possibly not the
            # version pinning we expect. We update the Umbrella one last time
            # to fetch the correct third-party deps.
            make -C "$umbrella" clean-3rd-party-repos
            make -C "$umbrella" up
            make -C "$umbrella/deps/rabbit" test-dist
            rm -rf "$umbrella"/deps/rabbitmq_website
            rm -rf "$umbrella"/deps/rabbitmq_prometheus/docker
            rm -rf "$umbrella"/deps/*/{.git,test} "$umbrella"/.git
          fi
        done
    - name: CREATE SECONDARY UMBRELLAS ARCHIVE
      run: |
        set -ex
        tar cf - umbrellas | xz > secondary-umbrellas.tar.xz
    - name: UPLOAD SECONDARY UMBRELLAS ARCHIVE
      uses: actions/upload-artifact@v2
      with:
        name: secondary-umbrellas.tar.xz
        path: secondary-umbrellas.tar.xz
    #@ end
xref:
  name: xref
  #@ if build_erlang:
  needs: [prepare]
  #@ end
  runs-on: ubuntu-18.04
  if: #@ skip_ci_condition()
  #@yaml/text-templated-strings
  steps:
    - name: CHECKOUT REPOSITORY
      uses: actions/checkout@v2
    - name: COMPUTE TEST RESULT CACHE KEY
      id: analysis
      run: |
        tree_hash=$(git rev-parse HEAD:deps)
        echo "::set-output name=test_result_cache_key::$tree_hash"
    - name: FETCH TEST RESULT CACHE
      id: cache
      uses: actions/cache@v2
      with:
        path: test-result-cache/xref
        key: ${{ steps.analysis.outputs.test_result_cache_key }}
    - name: CONFIGURE OTP & ELIXIR
      if: steps.cache.outputs.cache-hit != 'true'
      uses: actions/setup-elixir@v1
      with:
        otp-version: #@ erlang_version
        elixir-version: #@ data.values.elixir_version
    #@ for dep in [d for d in data.values.deps if not getattr(d, "skip_xref", False)]:
    - name: RUN XREF (@= dep.name @)
      if: steps.cache.outputs.cache-hit != 'true'
      run: |
        make -C deps/(@= dep.name @) xref \
          base_rmq_ref=(@= data.values.base_rmq_ref @) \
          current_rmq_ref=${{ steps.ref.outputs.branch_or_tag_name }}
    #@ end
    - name: CACHE SUCCESSFUL TEST RESULT
      if: steps.cache.outputs.cache-hit != 'true'
      run: |
        mkdir -p test-result-cache
        date > test-result-cache/xref

#@ if erlang_version != "git":
dialyze:
  name: dialyze
  #@ if build_erlang:
  needs: [prepare]
  #@ end
  runs-on: ubuntu-18.04
  if: #@ skip_ci_condition()
  #@yaml/text-templated-strings
  steps:
    - name: CHECKOUT REPOSITORY
      uses: actions/checkout@v2
    - name: COMPUTE TEST RESULT CACHE KEY
      id: analysis
      run: |
        tree_hash=$(git rev-parse HEAD:deps)
        echo "::set-output name=test_result_cache_key::$tree_hash"
    - name: FETCH TEST RESULT CACHE
      id: cache
      uses: actions/cache@v2
      with:
        path: test-result-cache/dialyze
        key: ${{ steps.analysis.outputs.test_result_cache_key }}
    - name: CONFIGURE OTP & ELIXIR
      if: steps.cache.outputs.cache-hit != 'true'
      uses: actions/setup-elixir@v1
      with:
        otp-version: #@ erlang_version
        elixir-version: #@ data.values.elixir_version
    #@ for dep in [d for d in data.values.deps if not getattr(d, "skip_dialyzer", False)]:
    - name: RUN DIALYZE (@= dep.name @)
      if: steps.cache.outputs.cache-hit != 'true'
      run: |
        make -C deps/(@= dep.name @) dialyze \
          base_rmq_ref=(@= data.values.base_rmq_ref @) \
          current_rmq_ref=${{ steps.ref.outputs.branch_or_tag_name }} \
          FULL=
    #@ end
    - name: CACHE SUCCESSFUL TEST RESULT
      if: steps.cache.outputs.cache-hit != 'true'
      run: |
        mkdir -p test-result-cache
        date > test-result-cache/dialyze
#@ end
#@ end
